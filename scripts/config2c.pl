use strict;

# Script to generate source code for a classifier based on a
# config-file. Useful for having default classifiers statically in
# memory.  It generates a constant classifier that should be placed in
# its own source-file. The classifier, defined at the bottom should be
# renamed to a unique name. (marked with a comment in the output)

# This interpreter has stricter requirements on the input format than
# the one in the C-code, since it is only for internal use. It also
# doesn't do any syntax checks, so it will only work on valid config
# files. 

my %types;
my %atoms;
my %classes;
my %residues;
my $n_classes = 0;
my $n_residues = 0;
my $atom_flag = 0;
my $type_flag = 0;
while (<>) {
    next if (/^#/);
    $_ =~ s/^(.*)#.*/$1/; # strip comments
    next if (/^\s*$/);
    if (/^types:/) {
        $type_flag = 1;
        $atom_flag = 0;
        next;
    }
    if (/^atoms:/) {
        $type_flag = 0;
        $atom_flag = 1;
        next;
    }
    if ($type_flag) {
        my ($name,$radius,$class) = split /\s+/, $_;
        $types{$name}{radius} = $radius;
        $types{$name}{class} = $class;
        if (! exists $classes{$class}) {
            $classes{$class} = $n_classes;
            ++$n_classes;
        }
    }
    if ($atom_flag) {
        my ($res,$atom,$type) = split /\s+/, $_;
        $atoms{$res}{$atom} = $type;
        if (! exists $residues{$res}) {
            $residues{$res} = $n_residues;
            ++$n_residues;
        }
    }
}

print "#include \"classifier.h\"\n\n";
print "/* Autogenerated code from the script config2c.pl */\n\n";
print "static const char *residue_name[] = {";
print "\"$_\", "foreach (keys %residues);
print "};\n";
print "static const char *class_name[] = {";
print "\"$_\", "foreach (keys %classes);
print "};\n\n";
foreach my $res (keys %residues) {
    my @atom_names = keys %{$atoms{$res}};
    print "static const char *$res\_atom_name[] = {";
    print "\"$_\", " foreach (@atom_names);
    print "};\n";
    print "static double $res\_atom_radius[] = {";
    print $types{$atoms{$res}{$_}}{radius},", " foreach (@atom_names);
    print "};\n";
    print "static int $res\_atom_class[] = {";
    print $classes{$types{$atoms{$res}{$_}}{class}},", " foreach (@atom_names);
    print "};\n";
    print "static struct classifier_residue $res\_cfg = {\n";
    print "    .name = \"$res\", .n_atoms = ", scalar keys %{$atoms{$res}},",\n";
    print "    .atom_name = (char**)$res\_atom_name,\n";
    print "    .atom_radius = (double*)$res\_atom_radius,\n";
    print "    .atom_class = (int*)$res\_atom_class };\n\n"
}
print "static struct classifier_residue *residue_cfg[] = {\n    ";
foreach my $res (keys %residues) {
    print "&$res\_cfg, ";
}
print "};\n";

print "static struct classifier_config freesasa_auto_config = {\n";
print "    .n_residues = $n_residues, .n_classes = $n_classes,\n";
print "    .residue_name = (char**)residue_name,\n";
print "    .class_name = (char**)class_name,\n";
print "    .residue = (struct classifier_residue **)residue_cfg\n";
print "};\n\n";
print "static void dummy_free(void *arg) {}\n\n";
print "// This should be renamed \n";
print "const freesasa_classifier freesasa_default_classifier = {\n";
print "    .config = &freesasa_auto_config,\n";
print "    .n_classes = $n_classes,\n";
print "    .radius = freesasa_classifier_config_radius,\n";
print "    .sasa_class =freesasa_classifier_config_class,\n";
print "    .class2str = freesasa_classifier_config_class2str,\n";
print "    // Since this object is const, calling free should emit compiler warnings.\n";
print "    .free_config = dummy_free, \n";
print "};\n";
      
